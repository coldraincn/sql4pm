## 修改表结构  
第一次建立box表的时候我们没有设置主键，所以要修改表结构，将id设为自增长的主键。  
1. 首先删除表中所有数据，或者id重复的数据，以防出问题，`delete from box;`  
2. 将id设置为主键  
    ```
    alter table box 
    change column `id` `id` int(11) not null auto_increment ,
    add primary key (`id`);
    ```  
3. 添加数据

## 1. 查询表中所有列的信息  
语法：`select * from 数据表;`  

`select * from factory;`    

```
mysql> select * from box;
+------+--------------+-------+
| id   | name         | color |
+------+--------------+-------+
|    3 | 中端盒子     | 紫    |
|    4 | 高端盒子     | 蓝    |
+------+--------------+-------+
2 rows in set (0.00 sec)
```    

## 2. 查询固定的列  
语法：`select 列名1,列名2,... from 数据表;`
`select id,name from box;`  

```
mysql> select id,name from box;
+----+--------------+
| id | name         |
+----+--------------+
|  3 | 中端盒子     |
|  4 | 高端盒子     |
+----+--------------+
2 rows in set (0.00 sec)
```  

## 3. 将查询的列按照别名展示  
语法：`select 列名1 as 新列名1,列名2 as 新列名2,... from 数据表;`,新的列表只是展示用，而不会真的修改原表内容。    
`select id as box_id,name as box_name from box;`  

```
mysql> select id as box_id,name as box_name from box;
+--------+--------------+
| box_id | box_name     |
+--------+--------------+
|      3 | 中端盒子     |
|      4 | 高端盒子     |
+--------+--------------+
2 rows in set (0.00 sec)
```

## 4. 条件查询  
语法：`select 列名1  [as 新列名1],列名2 [as 新列名],... from 数据表 where 条件;`,先随意插入一些数据  
```
mysql> select * from box;
+----+--------------+-------+
| id | name         | color |
+----+--------------+-------+
|  3 | 中端盒子     | 紫    |
|  4 | 高端盒子     | 蓝    |
|  5 | 中端盒子     | 红    |
|  6 | 中端盒子     | 红    |
|  7 | 中端盒子     | 红    |
|  8 | 高端盒子     | 红    |
|  9 | 高端盒子     | 红    |
+----+--------------+-------+
```  

1. 如果查询颜色为红色的盒子`select * from box where color='红';`  

    ```
    mysql> select * from box where color='红';
    +----+--------------+-------+
    | id | name         | color |
    +----+--------------+-------+
    |  5 | 中端盒子     | 红    |
    |  6 | 中端盒子     | 红    |
    |  7 | 中端盒子     | 红    |
    |  8 | 高端盒子     | 红    |
    |  9 | 高端盒子     | 红    |
    +----+--------------+-------+
    5 rows in set (0.00 sec)
    ```   

2. 如果查询颜色为红色的高端盒子`select * from box where color='红' and name='中端盒子';`    

    ```
    mysql> select * from box where color='红' and name='中端盒子';
    +----+--------------+-------+
    | id | name         | color |
    +----+--------------+-------+
    |  5 | 中端盒子     | 红    |
    |  6 | 中端盒子     | 红    |
    |  7 | 中端盒子     | 红    |
    +----+--------------+-------+
    3 rows in set (0.00 sec)
    ```  

3. 查询id小于7的高端盒子`select * from box where id<7 and name='高端盒子';`  

    ```
    mysql> select * from box where id<7 and name='高端盒子';
    +----+--------------+-------+
    | id | name         | color |
    +----+--------------+-------+
    |  4 | 高端盒子     | 蓝    |
    +----+--------------+-------+
    1 row in set (0.00 sec)
    ```  

4. 查询中端盒子或者颜色是蓝色的盒子，`select * from box where name='中端盒子' or color='蓝';`   

    ```  
    mysql> select * from box where name='中端盒子' or color='蓝';
    +----+--------------+-------+
    | id | name         | color |
    +----+--------------+-------+
    |  3 | 中端盒子     | 紫    |
    |  4 | 高端盒子     | 蓝    |
    |  5 | 中端盒子     | 红    |
    |  6 | 中端盒子     | 红    |
    |  7 | 中端盒子     | 红    |
    +----+--------------+-------+
    5 rows in set (0.00 sec)
    ```    

5. 查询终端盒子中颜色不是红色的盒子，`select * from box where name='中端盒子' and color<>'红';`  
mysql> select * from box where name='中端盒子' and color<>'红';  

    ```
    +----+--------------+-------+
    | id | name         | color |
    +----+--------------+-------+
    |  3 | 中端盒子     | 紫    |
    +----+--------------+-------+
    1 row in set (0.00 sec)
    ```    

6. 查询颜色不在红色和紫色的所有盒子，`select * from box where color not in('红','紫');`,(如果查询颜色在红色和紫色中的盒子，把not去掉，select * from box where color in ('红','紫');，这等于select * from box where color='红' and color='紫';)   

    ```
    mysql> select * from box where color not in('红','紫');
    +----+--------------+-------+
    | id | name         | color |
    +----+--------------+-------+
    |  4 | 高端盒子     | 蓝    |
    +----+--------------+-------+
    1 row in set (0.00 sec)
    ```    

7. 查询盒子id在1到3的盒子,`select * from box where id between 1 and 3;`或者`select * from box where id>=1 and id<=3;`  

    ```
    mysql> select * from box where id between 1 and 3;
    +----+--------------+-------+
    | id | name         | color |
    +----+--------------+-------+
    |  1 | 终端盒子     | 紫    |
    |  2 | 高端盒子     | 蓝    |
    |  3 | 中端盒子     | 红    |
    +----+--------------+-------+
    3 rows in set (0.00 sec)

    mysql> select * from box where id>=1 and id<=3;
    +----+--------------+-------+
    | id | name         | color |
    +----+--------------+-------+
    |  1 | 终端盒子     | 紫    |
    |  2 | 高端盒子     | 蓝    |
    |  3 | 中端盒子     | 红    |
    +----+--------------+-------+
    3 rows in set (0.00 sec)
    ```  

8. 模糊查询。使用`like` 关键词。  `%`表示任意字符，例如'ab%'将匹配'ab'，'abc'，'abcd';'%ab'可以匹配'ab','cab','cdab'.
`select * from box where name like '高%';`如果是like后面不加%,like与等号`=`一样。  `_`下划线表示单个字符，'ab_'可以匹配'abc','abd',不能匹配'ab','abcd',可以用多个下划线表示匹配多个字符，比如'ab___',有三个下划线，可以匹配'abcde'  

    ```
    mysql> select * from box where name like '高%';
    +----+--------------+-------+
    | id | name         | color |
    +----+--------------+-------+
    |  2 | 高端盒子     | 蓝    |
    |  6 | 高端盒子     | 红    |
    |  7 | 高端盒子     | 红    |
    +----+--------------+-------+
    3 rows in set (0.00 sec)

    mysql> 
    ```

9. 排序  
在box数据库的factory表添加一些数据，随意填写，时间尽量不一样  

    ```
    mysql> select * from factory;
    +----+---------------+---------------------+
    | id | name          | build_time          |
    +----+---------------+---------------------+
    |  1 | 盒子工厂1     | 2010-04-05 12:30:32 |
    |  2 | 盒子工厂2     | 2010-04-06 12:30:32 |
    |  3 | 盒子工厂3     | 2011-04-05 12:30:32 |
    |  4 | 盒子工厂4     | 2009-04-05 12:30:32 |
    |  5 | 盒子工厂5     | 2003-04-05 12:30:32 |
    |  6 | 盒子工厂6     | 2010-05-05 12:30:32 |
    |  7 | 盒子工厂7     | 2018-04-05 12:30:32 |
    |  8 | 盒子工厂8     | 2010-08-05 12:30:32 |
    +----+---------------+---------------------+
    8 rows in set (0.00 sec)
    ```
    排序的语法是：`select 列名,... from 表名 where 条件  order by 排序字段  [升序或者降序];`,升序使用`asc`,降序使用`desc`  
    例如我们要按照工厂建立的时间先后顺序查询工厂信息，我们使用语句`select * from factory order by build_time asc;`   

    ```
    mysql> select * from factory order by build_time asc;
    +----+---------------+---------------------+
    | id | name          | build_time          |
    +----+---------------+---------------------+
    |  5 | 盒子工厂5     | 2003-04-05 12:30:32 |
    |  4 | 盒子工厂4     | 2009-04-05 12:30:32 |
    |  1 | 盒子工厂1     | 2010-04-05 12:30:32 |
    |  2 | 盒子工厂2     | 2010-04-06 12:30:32 |
    |  6 | 盒子工厂6     | 2010-05-05 12:30:32 |
    |  8 | 盒子工厂8     | 2010-08-05 12:30:32 |
    |  3 | 盒子工厂3     | 2011-04-05 12:30:32 |
    |  7 | 盒子工厂7     | 2018-04-05 12:30:32 |
    +----+---------------+---------------------+
    8 rows in set (0.00 sec)
    ```  

    可以看到表格根据build_time时间先后排序  

    如果我们按照建造时间时间倒序查询工厂，使用语句`select * from factory order by build_time desc;`  

    ```

    mysql> select * from factory order by build_time desc;
    +----+---------------+---------------------+
    | id | name          | build_time          |
    +----+---------------+---------------------+
    |  7 | 盒子工厂7     | 2018-04-05 12:30:32 |
    |  3 | 盒子工厂3     | 2011-04-05 12:30:32 |
    |  8 | 盒子工厂8     | 2010-08-05 12:30:32 |
    |  6 | 盒子工厂6     | 2010-05-05 12:30:32 |
    |  2 | 盒子工厂2     | 2010-04-06 12:30:32 |
    |  1 | 盒子工厂1     | 2010-04-05 12:30:32 |
    |  4 | 盒子工厂4     | 2009-04-05 12:30:32 |
    |  5 | 盒子工厂5     | 2003-04-05 12:30:32 |
    +----+---------------+---------------------+
    8 rows in set (0.00 sec)
    ```  

    *排序的时候可能某个字段的数据相同，那么我们可能需要其他字段排序，例如可能有多个工厂建造时间相同，那么我们再根据id进行排序，可以使用`select * from factory order by build_time desc,id asc;`,那么先按照时间降序排序，如果时间相同的之间再按照id升序，多个列的排序用逗号隔开*  

10. 分页  
如果数据很多，我们查询的时候不可能把所有数据查询出来，那么我们可能需要分页查询，分页查询的基础语法是`select 列名,... from 表名  [条件]  [排序]  limit 每页条数  offset 索引位置;`,使用这条语句，系统会根据limit后面的"每页条数"自动帮我们分页，系统会计算总条数，然后除以"每页条数"可以得到数据总共几页，在计算机一些编程语言中，0代表第一个，如果我们查询从第一条数据展示offset后面写0，如果我们查询从第五个数据开始展示，后面写4.如果我们查询工厂，每页是3条，查询从第二个数据开始，语句是`select * from factory limit 3 offset 1;`,可以看到我们的id从1开始显示3条  

    ```
    mysql> select * from factory limit 3 offset 1;
    +----+---------------+---------------------+
    | id | name          | build_time          |
    +----+---------------+---------------------+
    |  2 | 盒子工厂2     | 2010-04-06 12:30:32 |
    |  3 | 盒子工厂3     | 2011-04-05 12:30:32 |
    |  4 | 盒子工厂4     | 2009-04-05 12:30:32 |
    +----+---------------+---------------------+
    3 rows in set (0.00 sec)
    ```  
    那么怎么分页呢，例如我们现在有8条数据，每页显示3页，那么总共有8以为3，余数也为单独一页，则总共3页，123/456/78，那么第一页从第一条数据，id为1的开始，开始第一条刚才说是0开始；第二页从4开始，那么索引的位置是3，第三页从7开始，索引位置是6。那么我们可以归纳出，如果查询第n页，索引位置=(n-1)*每页条数;所以，我们把数据分成每页3条，查询第三页的数据，索引位置是(3-1)*3=6;语句为`select * from factory limit 3 offset 6;`    

    ```
    mysql> select * from factory limit 3 offset 6;
    +----+---------------+---------------------+
    | id | name          | build_time          |
    +----+---------------+---------------------+
    |  7 | 盒子工厂7     | 2018-04-05 12:30:32 |
    |  8 | 盒子工厂8     | 2010-08-05 12:30:32 |
    +----+---------------+---------------------+
    2 rows in set (0.00 sec)
    ```  

11. 排序分页  
按照建造时间顺序先排序，然后按照每页3条，查询第三页
`select * from factory order by build_time asc limit 3 offset 6;`  
    ```
    mysql> select * from factory order by build_time asc;
    +----+---------------+---------------------+
    | id | name          | build_time          |
    +----+---------------+---------------------+
    |  5 | 盒子工厂5     | 2003-04-05 12:30:32 |
    |  4 | 盒子工厂4     | 2009-04-05 12:30:32 |
    |  1 | 盒子工厂1     | 2010-04-05 12:30:32 |
    |  2 | 盒子工厂2     | 2010-04-06 12:30:32 |
    |  6 | 盒子工厂6     | 2010-05-05 12:30:32 |
    |  8 | 盒子工厂8     | 2010-08-05 12:30:32 |
    |  3 | 盒子工厂3     | 2011-04-05 12:30:32 |
    |  7 | 盒子工厂7     | 2018-04-05 12:30:32 |
    +----+---------------+---------------------+
    8 rows in set (0.00 sec)

    mysql> select * from factory order by build_time asc limit 3 offset 6;
    +----+---------------+---------------------+
    | id | name          | build_time          |
    +----+---------------+---------------------+
    |  3 | 盒子工厂3     | 2011-04-05 12:30:32 |
    |  7 | 盒子工厂7     | 2018-04-05 12:30:32 |
    +----+---------------+---------------------+
    2 rows in set (0.00 sec)
    ```  
12. 使用mysql workbench进行第11步，可以在上面状态栏的"File"->"New Query Tab"或使用默认的  
    ![workbench20](http://img.coldraincn.com/sql/workbench20.png)  
    在状态栏"File"->"Sava Script"可以保存我们写的语句


## 条件运算符  
比较运算符，表示比较列与期望的数据的比较，比如color='绿'  

|比较运算符|含义|
|--------|----|
|>|大于|
|<|小于|
|=|等于|
|<>|不等于|  

逻辑运算符，表示多个比较条件的组合，比如name='中端盒子' or color='蓝'   

|逻辑运算符|含义|
|--------|----|
|and|某某和某某|
|or|某某或某某|